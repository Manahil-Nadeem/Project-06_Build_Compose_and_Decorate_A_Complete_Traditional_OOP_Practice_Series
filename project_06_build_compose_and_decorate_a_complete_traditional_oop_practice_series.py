# -*- coding: utf-8 -*-
"""Project:06_Build_Compose_and_Decorate_A_Complete_Traditional_OOP_Practice_Series.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1vWecR0H73IE_U72HYps7aB1qouhjQzI0
"""

#1. Using self

class Student:
    def __init__(self, name, marks, grade):
        self.name = name
        self.marks = marks
        self.grade = grade

    def display(self):
        print(f"Student Name: {self.name}")
        print(f"Marks: {self.marks}")
        print(f"Grade: {self.grade}")

student1 = Student("Aliza", 85, "A-one🚀")
student1.display()

#Using CLS
class Counter:
    count = 0  # Class variable to keep track of the number of objects

    def __init__(self):
        Counter.count += 1  # Increment count when a new object is created

    @classmethod
    def show_count(cls):
        print(f"Total objects created: {cls.count}")

# Example usage
c1 = Counter()
c2 = Counter()
c3 = Counter()
c4 = Counter()
c5 = Counter()

Counter.show_count()

# 3. Public Variables and Methods
class Car:
    def __init__(self, brand):
        self.brand = brand  # Public variable

    def start(self):        # Public method
        print(f"The {self.brand} car has started.")

my_car = Car("Toyota")
print(my_car.brand)
my_car.start()

# 4. Class Variables and Class Methods
class Bank:
    bank_name = "Default Bank"  # Class variable shared by all instances

    def __init__(self, customer_name):
        self.customer_name = customer_name

    @classmethod
    def change_bank_name(cls, name):
        cls.bank_name = name  # Modify the class variable using cls

    def show(self):
        print(f"Customer: {self.customer_name}, Bank: {Bank.bank_name}")

b1 = Bank("Ali")
b2 = Bank("Basil")
b3 = Bank("Riaz")

b1.show()
b2.show()
b3.show()

# Change the bank name using class method
Bank.change_bank_name("Meezan Bank")

# Show updated names for both instances
b1.show()
b2.show()
b3.show()

# 5. Static Variables and Static Methods
class MathUtils:
    @staticmethod
    def add(a, b,c):
        return a + b - c
result = MathUtils.add(12, 7, 9)
print(f"The sum is: {result}")

# 6. Constructors and Destructors
class Logger:
    def __init__(self):
        print("Logger object created.")  # Constructor message when an object is created

    def __del__(self):
        print("Logger object destroyed.")  # Destructor message when an object is destroyed

logger1 = Logger()  # This will trigger the constructor
del logger1         # This will trigger the destructor

# 7. Access Modifiers: Public, Private, and Protected
class Employee:
    def __init__(self, name, salary, ssn):
        self.name = name        # Public variable
        self._salary = salary   # Protected variable
        self.__ssn = ssn        # Private variable
emp = Employee("Jawed Iqbal", 50000, "143-45-67229")

# Accessing public variable
print(f"Name: {emp.name}")

# Accessing protected variable
print(f"Salary: {emp._salary}")

# Accessing private variable using name mangling
print(f"SSN (name mangling): {emp._Employee__ssn}")

# 8. The super() Function
class Person:
    def __init__(self, name):
        self.name = name  # Setting the name in the constructor

class Teacher(Person):
    def __init__(self, name, subject):
        super().__init__(name)  # Using super() to call the base class constructor
        self.subject = subject  # Adding subject field for the Teacher class

    def display(self):
        print(f"Teacher: {self.name}, Subject: {self.subject}")
teacher1 = Teacher("Sir Naeem", "Mathematics")
teacher1.display()

# 9. Abstract Classes and Methods
from abc import ABC, abstractmethod

# Abstract class Shape
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass  # Abstract method for calculating area

# Rectangle class inherits from Shape and implements area
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    def area(self):
        return self.width * self.height
rect = Rectangle(7, 5)
print(f"Area of Rectangle: {rect.area()}")

# 10. Instance Methods

class Dog:
    # Constructor to initialize name and breed
    def __init__(self, name, breed):
        self.name = name  # Instance variable for dog's name
        self.breed = breed  # Instance variable for dog's breed

    # Instance method to bark
    def bark(self):
        print(f"{self.name} says woof🎉!")
dog1 = Dog("Huddy", "Golden Retriever")
dog1.bark()

# 11. Class Methods:

class Book:
    total_books = 0

    # Constructor to initialize book details
    def __init__(self, title, author):
        self.title = title  # Instance variable for book title
        self.author = author  # Instance variable for book author
        # Increment the total book count each time a new book is created
        Book.increment_book_count()

    # Class method to increment the total book count
    @classmethod
    def increment_book_count(cls):
        cls.total_books += 1

book1 = Book("Mushaf" , "Nimra Ahmed")
book2 = Book("Jannat ke Patte", " Umera Ahmed")
book3 = Book("Raja Gidh", "Bano Qudsia")
book4 = Book("Aangan", "Khadeeja Mastoor")
print(f"Total books added: {Book.total_books}")

# 12. Static Methods:

class TemperatureConverter:
    # Static method to convert Celsius to Fahrenheit
    @staticmethod
    def celsius_to_fahrenheit(c):
        return (c * 9/5) + 32
celsius_temp = 25
fahrenheit_temp = TemperatureConverter.celsius_to_fahrenheit(celsius_temp)

print(f"{celsius_temp}°C is equal to {fahrenheit_temp}°F")

# 13. Composition:

class Engine:
    def start(self):
        return "Engine started but wait for few seconds🔥!"
class Car:
    def __init__(self, engine):
        self.engine = engine  # Composition: Car has an Engine

    def start_car(self):
        return self.engine.start()  # Accessing Engine's method

my_engine = Engine()
my_car = Car(my_engine)

print(my_car.start_car())

# 14. Aggregation:

class Employee:
    def __init__(self, name, emp_id):
        self.name = name
        self.emp_id = emp_id

    def get_details(self):
        return f"Employee Name: {self.name}, ID: {self.emp_id}"

#uses aggregation
class Department:
    def __init__(self, name, employee):
        self.name = name
        self.employee = employee
    def show_department_details(self):
        return f"Department: {self.name}, {self.employee.get_details()}"

# Create an Employee object independently
emp1 = Employee("Ayana Sheikh", 141)

# Pass the existing Employee to a Department (aggregation)
dept1 = Department("Human Resources", emp1)


print(dept1.show_department_details())

# 15. Method Resolution Order (MRO) and Diamond Inheritance:

# Base class A
class A:
    def show(self):
        print("Show from class A")

# Class B inherits from A
class B(A):
    def show(self):
        print("Show from class B")

# Class C also inherits from A
class C(A):
    def show(self):
        print("Show from class C")

# Class D inherits from both B and C
class D(B, C):
    pass  # Inherits everything from B and C

# Create an object of class D
d = D()
d.show()
print(D.__mro__)

# 16. Function Decorators:

def log_function_call(func):
    def wrapper():
        print("🔔 Function is being called...")
        return func()
    return wrapper

# Function to decorate
@log_function_call
def say_hello():
    print("👋 Hello!")
say_hello()

# 17. Class Decorators:

def add_greeting(cls):
    def greet(self):
        return "👋 Hello from Decorator!"
    cls.greet = greet
    return cls

# Apply the class decorator to Person
@add_greeting
class Person:
    def __init__(self, name):
        self.name = name

# Create an instance and use the added greet() method
p = Person("Ali Raza")
print(p.greet())

# 18. Property Decorators: @property, @setter, and @deleter:

class Product:
    def __init__(self, price):
        self._price = price  # Private attribute

    # Getter method using @property
    @property
    def price(self):
        print("📦 Getting the price...")
        return self._price

    # Setter method using @price.setter
    @price.setter
    def price(self, value):
        if value < 0:
            print("⚠️ Price cannot be negative!")
        else:
            print("🔧 Setting the price...")
            self._price = value

    # Deleter method using @price.deleter
    @price.deleter
    def price(self):
        print("❌ Deleting the price...")
        del self._price
p = Product(100)

print(p.price)
p.price = 150
print(p.price)
p.price = -50
del p.price

# 19. callable() and __call__():

class Multiplier:
    def __init__(self, factor):
        self.factor = factor  # Set the multiplication factor

    def __call__(self, value):
        return value * self.factor

# Create an instance of Multiplier
double = Multiplier(4)

# Check if the object is callable
print(callable(double))

# Use the object like a function
result = double(12)
print(f" Result: {result}")

# 20. Creating a Custom Exception:

class InvalidAgeError(Exception):
    def __init__(self, message="❌ Age must be 18 or above."):
        super().__init__(message)

# Function to check age
def check_age(age):
    if age < 18:
        raise InvalidAgeError()
    print("✅ Age is valid.")
try:
    user_age = int(input("Enter your age: "))
    check_age(user_age)
except InvalidAgeError as e:
    print(e)

# 21. Make a Custom Class Iterable:

class Countdown:
    def __init__(self, start):
        self.start = start
        self.current = start

    def __iter__(self):
        return self
    def __next__(self):
        if self.current > 0:
            # Decrement the countdown and return the current value
            self.current -= 1
            return f"{self.current + 1}"
        else:
            raise StopIteration  # Stop iteration when we reach 0
countdown = Countdown(20)

# Using the Countdown object in a for loop
for number in countdown:
    print(number)

